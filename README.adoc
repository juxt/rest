= How to write a RESTful Web service
:toc: left
:toclevels: 2
:sectnums:
:sectlevels: 3
:includedir:

Welcome to this unofficial yet comprehensive guide to creating
https://en.wikipedia.org/wiki/Representational_state_transfer[REST]ful services
that communicate over HTTP.

By comprehensive, we mean that _every_ aspect of core HTTP is covered: content
negotiation, conditional requests, ranges, authentication, all request methods
and headers, and all response status codes and headers defined by the RFCs that
govern HTTP today: https://tools.ietf.org/html/rfc7230[7230],
https://tools.ietf.org/html/rfc7231[7231],
https://tools.ietf.org/html/rfc7232[7232],
https://tools.ietf.org/html/rfc7233[7233],
https://tools.ietf.org/html/rfc7234[7234] and
https://tools.ietf.org/html/rfc7235[7235].

This guide is intended for developers wishing to write HTTP services from
scratch, or developers building public or organisation-wide web-frameworks that
seek to conform to the requirements of HTTP and REST.

It is structured as a step-by-step guide.

== Introduction

////
Mention how you should strive not to follow this procedure for every endpoint,
but establish resource metadata which can influence processing and make your
handlers far more reusable and generic.
////

include::{includedir}/intro-language-setup.adoc[]

== Step-by-step Guide

[[check-service-available]]
=== Is the service available?

[quote,,503 Service Unavailable -- Section 6.6.4 RFC 7231]
____
The 503 (Service Unavailable) status code indicates that the server
is currently unable to handle the request due to a temporary overload
or scheduled maintenance
____

. Check that your service is not overwhelmed with requests.

. If it is, throw an exception. Otherwise, go to <<check-implemented-method,the next
step>>.

NOTE: How you can tell this is beyond the scope of this guide. It might be a feature
of the web listener you are working with. Or you might want to build something
that signals that new web requests should temporarily suspended. If you don't
know, just skip this section, it's optional.

****
include::{includedir}/check-service-available.adoc[]
****

==== References

* 503 Service Unavailable -- https://tools.ietf.org/html/rfc7231#section-6.6.4[Section 6.6.4, RFC 7231]
* Retry-After -- https://tools.ietf.org/html/rfc7231#section-7.1.3[Section 7.1.3, RFC 7231]

[[check-implemented-method]]
=== Check method is implemented

[quote,,501 Not Implemented -- Section 6.6.2 RFC 7231]
____
The 501 (Not Implemented) status code indicates that the server does
not support the functionality required to fulfill the request.
____

The next step is to check whether the request method is one your implementation
recognises.

. Check if the *request method* is recognised.

.. If so, go to <<locate-resource,the next step>>.

.. If not, throw an exception containing a 501 `(Not Implemented)` error response.

****
include::{includedir}/check-known-method.adoc[]
****

==== References

* 501 Not Implemented -- https://tools.ietf.org/html/rfc7231#section-6.6.2[Section 6.6.2, RFC 7231]

[[locate-resource]]
=== Locate the resource

[quote,Resources -- Section 2 RFC 7231]
____
The target of an HTTP request is called a "resource".
____

. Use the URL of the request to lookup or otherwise locate the resource object (which can be null).

.. Hold this data structure as a variable, and go to <<the next step>>.

Typically, a resource object will include the following:

* The resource's identifier (the URI) or, at least, its path
* Which methods are allowed on the resource?
* Current representations
* Which ranges, if any, are acceptable?
* Authorization rules - who is allowed to access this resource and how?
* The allowed types of submitted representations
* Anything else that is useful

////
The set of *request method* tokens might very well depend on details in the
request. For example, a resource might allow a POST but only if the request is
_authorized_ to do so. So you can make use of any information in the request,
not just the URL, to determine the set of *request method* tokens
allowed. Moreover, if some attribute or attributes of a resource are referred to
in making such a decision, or affect the processing of request methods (at the
minimum, the *request method* in the current request), then these should be
included in the *resource* too.
////

TIP: Try to avoid using the *request method* when locating a resource--a
*resource* value should encompass _all_ its methods.

****
include::{includedir}/locate-resource.adoc[]
****

=== Authenticate the request

. Add to the request, any roles, credentials or entitlements that can be
acquired. Use information in the resource found in <<locate-resource>> to
determine the *authentication scheme* and/or *protection space*.

.. This usually involved inspecting the request's `Authorization` header and/or other
headers, frequently `Cookie` headers.

=== Authorize the request

. Update the resource object according to the authenticated request's roles,
credentials or other entitlements.

.. If the resource cannot be accessed without credentials, and if none have been
supplied (or ones that have been supplied are invalid) throw an exception that
contains a 401 response. This response may include a `WWW-Authenticate` header
to indicate to the user agent that it should resend the request with
credentials.

.. If the request does contain valid authenticated credentials, but they are
insufficient to provide access to the resource given the request's method, throw
an exception that contains a 403 response.

=== Validate the request with respect to the resource

. If the request is not valid, throw an exception containing a 400 response.

This step might also involve validating parameters, for example, to meet the expectations of a set of OpenAPI parameter declarations.

[[check-method-allowed]]
=== Check method allowed

. Check the request method against the methods allowed by the resource.

.. If the request method isn't allowed, throw an exception containing a 405
response and an `Allow` header.

=== Record the time

. Get the system time and store it in a variable.

=== Establish the current representations

. Using the resource, determine the current representations and store in a
variable.

=== Negotiate the most acceptable current representation

For the given *resource*, determine the content negotiation strategy and follow
one of the sections below (although it is permissable to use a hybrid or
combination of strategies).

TIP: If in doubt, use <<proactive-content-negotiation,proactive content negotiation>>, which is by far the most
commonly strategy.

* <<proactive-content-negotiation>>
* <<reactive-content-negotiation>>

[[proactive-content-negotiation]]
==== Proactive Content Negotiation

1. Determine the set of available current representations for the resource.

2. If step 1. yields no representations, and the method is a GET or HEAD, throw an exception containing a `404 (Not Found)` error
response.

3. Select the most acceptable representation from this set, using the preferences contained in the request.
.. If there is no such acceptable representation, and the method is a GET
or HEAD, throw an exception containing a `406 (Not Acceptable)` error
response. Construct a body containing links to each unacceptable representation
from step 1.
.. Otherwise store the most acceptable current representation in a variable called `selected-representation` to move to the next step.

include::{includedir}/proactive-content-negotiation.adoc[]

[[reactive-content-negotiation]]
==== Reactive Content Negotiation

1. Determine the set of available *representations* for the resource.

2. If step 1. yields no representations, return a 404 error response. Go to <<error-response>>.

3. Optionally, filter this set using the preferences contained in the request.

4. If step 3. yields a single representation, then use this as the representation and _move on to the next section_.

5. If step 3. yields multiple *representations*, respond with a 300 response and construct a body containing links to each representation in this filtered set.

=== Process the *request method*

Go to the relevant procedure below, corresponding to the request method.

. <<get>>
. <<post>>
. <<put>>
. <<delete>>
. <<patch>>
. <<options>>

[[get]]
=== GET (or HEAD)

NOTE: The procedure for HEAD is identical to that of GET, with the exception
that we do not produce any body in the response.

. Evaluate preconditions

. Optionally, if there is a `Range` header, parse it.

.. If the units of the range header isn't supported by the resource, throw an exception with a `400 Bad Request` error response.

.. If there is an `If-Range` header, process it (TODO)

. Get the payload of the selected representation

[[post]]
=== POST

[[put]]
=== PUT

[[delete]]
=== DELETE

[[patch]]
=== PATCH

[[options]]
=== OPTIONS


[[error-response]]
=== Send an error response

If you want to send an error response, you should decide whether to send a body
in the response. This might contain information about the error and explain to
the user-agent (or human) how to avoid the error in future.

. Perform content negotiation to establish the best representation to send.

. Add the *representation metadata* to the response headers, and stream the
*representation data* as the the *body* of the response.

// Local Variables:
// mode: outline
// outline-regexp: "[=]+"
// eval: (local-set-key (kbd "<M-up>") 'outline-move-subtree-up)
// eval: (local-set-key (kbd "<M-down>") 'outline-move-subtree-down)
// End:
